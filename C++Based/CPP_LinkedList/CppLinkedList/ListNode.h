#pragma once

#include <iostream>

using std::cin;
using std::cout;
using std::endl;

template <class T> class ListNode
{
public:
	ListNode();
	ListNode(T newData); // constructor - "constructs" a ListNode; initializes the object
	ListNode(const ListNode<T> &copy);  // copy constructor - implicitly invoked copying a ListNode object during construction of 
										// another ListNode object, or when a ListNode object is passed-by-value;
										// the compiler generated one would be ok here as well! shallow copy performed!

	~ListNode();               // destructor - implicitly invoked when a ListNode object leaves scope;
							   // the compiler generated one would be ok here as well!

							   // we will not define an explicit overloaded assignment operator (=). We will
							   // rely on the memberwise assignment generated by the compiler.

							   // getters
	T getData() const;                // used to retrieve a copy of the data in the node
	ListNode<T> * getNextPtr() const;      // used to retrieve a copy of the node's next pointer

										   // setters
	void setData(const T &newData);            // used to modify the data in the node
	void setNextPtr(ListNode<T> * const pNewNext); // used to modify the node's next pointer

private:
	T mData;                   // represents a score
	ListNode<T> *mpNext;            // should be set to NULL in the constructor
};

template <class T>
ListNode<T>::ListNode()
{
	mpNext = nullptr;
}

template <class T>
ListNode<T>::ListNode(T newData)
{
	mData = newData;
	mpNext = nullptr;
}

template <class T>
// copy constructor - implicitly invoked copying a ListNode object during construction of 
// another ListNode object, or when a ListNode object is passed-by-value
ListNode<T>::ListNode(const ListNode<T> &copy)
{
	// shallow copy performed!
	mData = copy.mData;
	mpNext = copy.mpNext;
}

template <class T>
// destructor - implicitly invoked when a ListNode object leaves scope
ListNode<T>::~ListNode()
{
	// Yes, these nodes are dynamically allocated, but delete will be invoked invoked by functions in List.
	// Hence, don't need to deallocate the heap memory inside of this destructor!
	cout << "Inside ListNode's destructor!" << endl;
}

template <class T>
T ListNode<T>::getData() const // the const indicates "constant" function; can't modify the object's data members with this function
{
	return mData;
}

template <class T>
ListNode<T> * ListNode<T>::getNextPtr() const // the const indicates "constant" function; can't modify the object's data members with this function
{
	return mpNext;
}

template <class T>
void ListNode<T>::setData(const T &newData) // the const in this context ensures newData can't be modified
{
	mData = newData;
}

template <class T>
// the const in this context ensures pNewNext can't be modified;
// remember read as pNewNext is a constant pointer to a ListNode - the ListNode object is not const though!
void ListNode<T>::setNextPtr(ListNode<T> * const pNewNext)
{
	mpNext = pNewNext;
}